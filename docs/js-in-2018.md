# Developping in javascript in 2018

Aha, so here you are reading this document trying to learn something about developping in Javascript in 2018... Well, you will learn tools and what they're for, but you'll need to practise to actually learn something!

So here we go.

First of here's a small diagram of what was in the box for 2017

![Front end developpement in 2017](https://cdn-images-1.medium.com/max/2000/1*PNATyAREKSIR-v8AmWoq8w.png)

And we're almost going to take the same approach. 
We will see what Node.js is, and how it changed javascript developement. 
Second, we will look at developement tolls, what they are for, and how to use them. 
And last but not least, learning to intergrate almost all of that with a framework.

But first of, let's get the basics of javascript in the box

# Node.js

Node.js is a javsacript runtime built upon google v8 javascrtipt engine. Not that you need to know what V8 is, neither what is a runtime. But ultimitly Node.js allows you to execute Javascript code on your machine.
That's a big, a HUGE game changer.
This means that you can write javascript. just like you would write php code.
You will need to install node.js on your machine. As of writing this tutorial, the official nightly build of node.js is `node.js v9.11.1`

Node.js is build upon a plugin system called `modules`. Node.js provides alot of modules, and you can import your own and create your own if you want to.
The cool thing is that you can import and use modules that are built for node.js that you can use on the web, and vice-versa. Although not all node.js modules are browser compatible! (you can't use Jquery in a Node.js context, but there is a Jquery module).

And that's where we're gonna leave node.js. Just know that we will use node.js to use the developpement tools later on.

## Node.js http

A little appart with node.js will be it's ability to be a full api to the system, which means opening and closing tcp ports. That makes node.js prone to creating, and managing http servers.

Here's a simple example from the docs:

```javascript
var http = require('http');

//create a server object:
http.createServer(function (req, res) {
  res.write('Hello World!'); //write a response to the client
  res.end(); //end the response
}).listen(8080); //the server object listens on port 8080
```

# Some basics

We won't view what the language looks like, but here are some principals that are widely used in the world of javascript.
Here's what we're gonna cover:
- ES6 / EcmaScript
- Callbacks
- Promises
- Async functions
- Immuability

## ES6 / EcmaScript

You might have heard this term somewhere on the interwebs. Well it's not for nothing. Javascripts real name is EcmaScript. As of right now we are at version 6, so ES6.

EcmaScript is a standard for javascript that is constantly evolving. Thus far some browsers can interpret ES6, but most of the old browsers can't.
Here's a !(full table)[https://kangax.github.io/compat-table/es6/] on what platform suport what feature!

Since the standard is always evolving, and most browsers can't catch up, developpers have made tools to convert this new fresh shiny ES6 into old code. The most popular tool is called `babel`.

Babel staticly reads your code, and converts your written code to old code. Babel has multiple plugins, that allow you to enable experimental features, or other. We won't go into much deatail about Babel modules (also called presets, or plugins), but just know they exist and are widely used.

## Callbacks

Callbacks are the basics of Javascript, it's what javascript is good at. Callbacks are functions run when a particular action is done. These callbacks generally allow for a programmer to call some user land code, when something happened or has ahppened. 
Generally they go like so:
```javascript
// cb is the callback passed to the function
function myFunc(cb){
  alert('let\'s code together');
  cb("wee");
}


myFunc(function(args){
  console.log(args) // will print "wee"
});
```

Here the callback is passed as an argument to `myFunc`, and is declaed inline.

We're gonna need to notion of callbacks, since it's a building block of javascript!

## Promises

Promises are the future of callbacks, and the future is now!
Well, let's not get too political, but in it's essence a promise is a callback that handles other callbacks.

It's great because it solves one problem that javascript developers struggle with, which is calback hell.
Here's an example:
![cb hell](https://image.slidesharecdn.com/asynchistory-170422024901/95/async-history-javascript-16-638.jpg?cb=1492829430)

But what is a promise, can I make my own? Yes of course, don't worry.
Here's what happens when you create a promise.
```javascript
function stuff() {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
      if(somethingIsOk)
        resolve("WOUHOU EVERYHTING IS OKEY");
      else
        reject(Error("Something went wrong"));
  });
}

// then you would call stuff and

stuff().then(resp => {
  console.log(resp) //should print "WOUHOU EVERYHTING IS OKEY" if everything ran smoothly
})
.catch(err => {
  console.log(err) //will be called if promise rejects
})

```

And the cool thing about promises is that you can return a promise in a promise, just like you would with callbacks, but you don't get that pyramid of doom.

Here's an example:
```javascript
function stuff() {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
      if(somethingIsOk)
        resolve("WOUHOU EVERYHTING IS OKEY");
      else
        reject(Error("Something went wrong"));
  });
}

function foo(args) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
      if(somethingIsOk)
        resolve("from foo promise: " + args);
      else
        reject(Error("Something went wrong"));
  });
}

// then you would call stuff and

stuff().then(resp => {
  return foo(resp) //pass to foo the response you got from stuff
})
// since promises are chainable
// we can listen to the result of foo in the next "then" block
.then(resp => { 
  console.log(resp) //will print "from foo primose: WOUHOU EVERYHTING IS OKEY"
})
//and if anything bad happens in both promises, well we catch the errors here
.catch(err => {
  console.log(err)
})
```

See how easy it is to chain Promises? Isn't it so much better than callbacks into callback into callback?

Promises are very widely used, and reduce alot of complexity in your code. Use them when you can.

## Async functions

Asnychronous functions, or async functions are a new type of function introduced in ES6.  You can skip this part if you're not interested in async functions and why they are great, but just know that they might pop up at the end of this document when we're gonna look into react.

They are used to, as their names says it, call a function asynchronously in a non blocking way. This means that you can run multiple async functions at once, without overlaping. Since it's a new feature, you will need to require the browserify plugin for it, which is called `transform-async-to-generator`. [Here a link](https://babeljs.io/docs/plugins/transform-async-to-generator/).

An asynchronous function can only be run just like a normal function, but it will create some sort of weird asynchrounous context. And in that context, you can wait for promises, or other asynchrounous functions.

Here's an example:

```
function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('resolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  var result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
}

asyncCall();

```

And that simplifies even more Promises!


# Developpement tools

So we have alot of tools available to develop in 2018, most of them written in javascript.

We'll first see the simple ones, command executors or cli helpers. Then we will see a bit on bundlers, and why you would use one. And to finish we will touch the tacky subjects of modules (they aren't developpement tools, but can be a bit special).
